// A _goroutine_ is a lightweight thread of execution.

package main

import ("fmt"
    "log"
    "gopkg.in/yaml.v2")

func f(from string) {
    for i := 0; i < 3; i++ {
        fmt.Println(from, ":", i)
    }
}


var data = `
a: Easy!
b:
  c: 2
  d: [3, 4]
`

type T struct {
        A string
        B struct {
                RenamedC int   `yaml:"dc"`
                D        []int `yaml:",flow"`
        }
}


func main1() {

    t := T{}
    
    err := yaml.Unmarshal([]byte(data), &t)
    if err != nil {
            log.Fatalf("error: %v", err)
    }
    fmt.Printf("--- t:\n%v\n\n", t)

    d, err := yaml.Marshal(&t)
    if err != nil {
            log.Fatalf("error: %v", err)
    }
    fmt.Printf("--- t dump:\n%s\n\n", string(d))

    m := make(map[interface{}]interface{})

    err = yaml.Unmarshal([]byte(data), &m)
    if err != nil {
            log.Fatalf("error: %v", err)
    }
    fmt.Printf("--- m:\n%v\n\n", m)

    d, err = yaml.Marshal(&m)
    if err != nil {
            log.Fatalf("error: %v", err)
    }
    fmt.Printf("--- m dump:\n%s\n\n", string(d))
//     // Suppose we have a function call `f(s)`. Here's how
//     // we'd call that in the usual way, running it
//     // synchronously.
//     f("direct")

    

//     // To invoke this function in a goroutine, use
//     // `go f(s)`. This new goroutine will execute
//     // concurrently with the calling one.
//     go f("goroutine")

//     // You can also start a goroutine for an anonymous
//     // function call.
//     go func(msg string) {
//         fmt.Println(msg)
//     }("going")

//     // Our two function calls are running asynchronously in
//     // separate goroutines now, so execution falls through
//     // to here. This `Scanln` code requires we press a key
//     // before the program exits.
//     var input string
//     fmt.Scanln(&input)
//     fmt.Println("done")
}
